05_Application Lifecycel management

Rolling updates.

The Rolling updates are done kind deployment.

This is to maximize high availabaility of POD by killing one old POD and creating one new POD in replication set.
This is like doing new release and rollback to old one if any issue in new release.

To roll back
>kubectl rollout undo deployment/myapp-deployment
This can be validate by checking replicasets
>kubectl get rs

More command in k8s-kcloud github documentation
--------------------------------------------

Commands and Arguments
More details and screenshot in word documentation "commands and Arguments"


------------------------------
Environment Variable in k8s

apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    dep: prod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
  env:
  - name: APP_TEAM
    value: finance
	

Environment Variable configMap
If there is more number of pod and more number of variable deploying those things in k8s-definition file will be difficult.
So that we can use the configmap -> ConfigMap is a separate file  which are reference to the pod-definition file
 1. Create a config mao
 2. Inject it to the POD

Create config map in imperative way
>kubectl create configmap <config-map-name> --from-literal=APP_COLOR=blue --from-literal=APP_OWNER=finance
The above would be difficult in adding more env variable. So that we can pass the ev variable as files as shown below
> kubectl create configmap <config-name> --from-file=<path-to-file>
> kubectl create configmap <config-name> --from-file=app_config.properties

configmap.properties file contains
APP_COLOR=blue
APP_OWNER=finance

Creating configmap in declarative way
apiVersion: v1
kind: configMap
metadata:
	name: app-config
data:
	APP_NAME: billing
	APP_TEAM: finance
	
kubectl create -f config-map.yaml

NOTE: You can have as many config map as you want like for fromtend , mysql, redis and so on.

>kubectl get configmaps
>kubectl describe configmaps

Configuring the config map to the POD definition file --> IMPORTANT
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    dep: prod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
  envFrom:
  - configMapRef:
		name: app-config // This  is the name from configMap file mentioned in metadata
		

To Ingest single env varaible we can use
envFrom:
  - configMapKeyRef:
		name: app-config //This  is the name from configMap file mentioned in metadata
		key: APP_COLOR
--------------------------------------------------------------------------------------------------

Secrets  and secrets in variables in K8s
For example storing password for mysqlDB. Configmap is literally a key-value pair and it will show the information.

Two steps in creating secrets
	1. Create a secret
	2. Inject it to POD

Imperative method of creating secret.
>kubectl create secret generic

>kubectl create secret generic <secret-name> --from-literal=APP_COLOR=blue --from-literal=APP_OWNER=finance
The above would be difficult in adding more secret variable. So that we can pass the secret env variable as files as shown below
> kubectl create secret generic <secret-name> --from-file=<path-to-file>
> kubectl create secret <secret-name> --from-file=app_config.properties


Declarative method of creating secret
>Kubectl create -f <key-definition>.yaml

Creating secret in declarative  --> IMPORTANT
apiVersion: v1
kind: Secret
metadata:
	name: app-secret
data:
	DB_USER_NAME: billing //It has to be in a hashed encoded format
	DB_HOST: finance.com
	DB_PASSWD: passwd  //It has to be in a hashed encoded format
	
How to convert plain text to encoded format? Please follow the below linux command
>echo -n 'password' | base64
TO Decode the value use the following command
>echo -n 'encoded-value' | base64 --decode


>kubectl get secrets
>kubectl describe secrets
TO view the secret values as well
>kubectl get secret app-secret -o yaml -> This will display the secret value as well.


Configuring the secret map to the POD definition file --> IMPORTANT
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    dep: prod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
  envFrom:
  - secretRef:
		name: app-secret

To Ingest single secret env varaible we can use
envFrom:
  - name: DB_PASSWORD
	valueFrom:
	 secretKeyRef:
		name: app-secret //This  is the name from secret file mentioned in metadata
		key: DB_PASSWD //Key name in that definition file (refer above secret-Defenition file)
		
		
---------------------------------------------------------------------------------------------------

Multi container PODS ie; multi container in one pod

apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    dep: prod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
	ports:
	  - containerPort: 8080
  - name: console-container
    image: console:latest
	ports:
	  - containerPort: 8085
  - name: polyglot-container
    image: polyglot:latest
	ports:
	  - containerPort: 8086
--------------------------------------------------------------------------------
INIT Containers (initContainer)


apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox
    command: ['sh', '-c', 'git clone <some-repository-that-will-be-used-by-application> ; done;']


